package threads.forkJoin;

public class ForkJoinTest {

/**
 * ForkJoin框架是jdk 7提供的一个用于并行执行的任务框架，是把一个大任务分割成若干个小任务，最终汇总每个小任务的结果后得到大任务结果的框架。
 * 		工作窃取算法是指某个线程从其他队列里窃取任务来执行，执行一个比较大的任务分割为若干互相不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放在不同的队列里，
 * 			并为每个队列创建一个单独的线程执行队列里的任务，线程和队列一一对应。有的线程会把自己队列里的任务先干完，其他线程队列里还有任务等待处理，此时干完活的线程可以帮其他线程干活。
 * 			为了减少窃取任务线程和被窃取任务线程之间的竞争通常使用双端队列，被窃取线程永远从队列头部拿任务执行，窃取线程永远从队列尾部拿任务执行。
 * 
 * 缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时，并且该算法会消耗更多的资源系统，比如创建多了线程个双端队列。
 * 
 * 
 * 步骤1:首先需要有一个fork类来把大任务分割成子任务，有可能子任务还很大需要继续等割，直到任务足够小
 * 		创建一个ForkJoin任务，它提供在任务中执行fork／join的机制，不需要直接继承ForkJoinTask类，只需要继承它的子类
 * 			RecursiveAction:用于没有结果的任务
 * 			RecursiveTask:用于有返回结果的任务
 * 
 * 步骤2:执行任务并合并结果，分割子任务并放在双端队列中，然后几个启动线程分别从双端队列中获取任务执行，子任务执行完的结果统一放在一个队列里，启动以一个线程从队列里拿数据，然后合并这些数据
 * 		ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。
 * 		任务分割出的子任务会添加到当前工作线程维护双端队列中，进入队列头部，当一个工作线程的队列暂时没有任务，它会随机从其他工作线程队列尾部获取一个任务。
 * 
 */
}
