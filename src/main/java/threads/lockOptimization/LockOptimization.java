package threads.lockOptimization;

public class LockOptimization {

	/**
	 * java虚拟机对锁优化做的努力
	 * 
	 * 1.锁偏向
	 * 		如果一个线程获得了锁，那么锁就进入偏向模式。当这个程序再次请求锁是，无需做任何同步操作。
	 * 		这样节省了大量的有关锁的申请操作，从而提高了程序的性能。因此在几乎没有锁竞争的场合，偏向锁有比较好的优化效果。
	 * 		在竞争激烈的情况下，最有可能的情况是不同的线程来申请锁，这样偏向模式会失效，因此不如不开启锁偏向。
	 * 		使用java虚拟机参数-XX:+UseBiasedLocking
	 * 
		    Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入
			了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要花费
			CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，
			如果测试失败，则需要再测试下 Mark Word中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果没有设置，则使用 CAS 竞争锁，如果设置了，
			则尝试使用 CAS 将对象头的偏向锁指向当前线程。

		    偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤
			销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程
			不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的
			Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。
	 * 		
	 * 
	 * 2.轻量级锁
	 * 		如果偏向锁失败，虚拟机不会立即挂起线程，将对象头部作为指针，指向持有线程堆栈内部，来判断一个线程是否持有对象锁。如果线程线程获得轻量级锁成功，则可以顺利进入临界区
	 * 		如果轻量级锁加锁失败，则表示其他线程优先抢到了锁，那么当前线程会膨胀成重量级锁。
	 * 
	 * 		轻量级锁加锁：线程在执行同步块之前， JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，
			官方称为Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，
			表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志
			的状态值变为”10”，Mark Word中存储的就是指向重量级（互斥量）的指针。
			       轻量级锁解锁：轻量级解锁时，会使用原子的 CAS 操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，
			表示当前锁存在竞争，锁就会膨胀成重量级锁
	 * 
	 * 
	 * 3.自旋锁
	 * 		锁膨胀后，虚拟机为了避免线程真是的在操作系统层面挂起，虚拟机还会做最后的努力--自旋锁
	 * 		由于当前线程暂时无法获得锁，但是具体什么时候用获得锁是一个未知数，也许在几个cpu时钟后就可以获得锁，虚拟机会让当前线程做几个空循环，如果可以拿到锁那么就进入临界区，如果失败就挂起
	 * 
	 * 
	 * 4.锁消除
	 * 		java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。
	 * 		锁消除涉及的一项关键技术是逃逸分析，逃逸分析必须在-sever下，可以使用-XX：+DoEscapeAnlysis参数打开逃逸分析，使用-XX：+EliminateLocks参数打开锁消除。
	 * 
	 * 
	 *  偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。
        一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个
		线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将
		对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。
			一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，
			如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，
			（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。
        轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。
        但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。
        
        偏，轻，重锁，分别解决三个问题，只有一个线程进入临界区，多个线程交替进入临界区，多线程同时进入临界区
        
        Mark Word
        		而Mark Word是一个复用的数据结构。在不同的对象状态下，其存储的数据也不尽相同。
        		标志位：
			01：表示对象没有被锁定。bitfields中分别存放了对象的identify hash code，分段年龄，偏向锁标志。
				identify hash code是由System.identityHashCode()获取，它是一个随机的字符串，与对象的内容无关。
				这个值在对象的生命周期内是不可变的，因此这个值必须被缓存，因为在对象的状态改变的时候，对应的hash值会被覆盖，回复到unlocked的时候，需要将缓存值重新写入。
			00：轻量锁标志。bitfields存放了指向lock record的地址，也就是指针。
			10：锁膨胀标志（也就是重量锁的时候）。bitfields存放了指向monitor的指针。如果线程B试图获取线程A已经获得到的锁的时候，对象的状态会变成10。
			11：gc标志。这个标志只在GC的时候使用，用于表示哪个对象还是可以达到的，也就是不用清除。
			01:：偏向锁标志。bitfields分别存放了线程ID，epoch，分段年龄，偏向锁标志。
			上面提到的分段年龄是指：新建对象的分段年龄为0，之后每次在新生代拷贝一次就年龄+1，当年龄超过一个阈值之后，就会被丢入老年代。
	 */
}
