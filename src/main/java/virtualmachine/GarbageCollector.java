package virtualmachine;
/**
 * 垃圾收集器
 * @author gaobo
 *
 */
public class GarbageCollector {

	//新生代垃圾收集器：
		//Serial收集器是一个单线程的收集器，只会使用一个CPU或者一个收集线程去完成垃圾收集工作，并且其进行垃圾收集时必须暂停所有的工作线程。对于单个CPU环境来说，由于没有线程交互的开销在单核下最优。
		//ParNew收集器是Serial的所线程版本，除了多线程进行垃圾收集之外，其余行为包括Serial收集器所有的控制参数
		//Parallell Scavenge收集器目标是达到一个可控制的吞吐量，所谓吞吐量就是cpu用于运行用户代码的时间与cpu总消耗时间的比值
	
	
	
	//老年代垃圾收集器：
		//SerialOld是Serial收集器的老年代版本，同样是单线程，采用标记整理算法。
		//Parallel Old是Parallel收集器的老年代版本，使用多线程和标记整理算法，在注重吞吐量和CPU资源敏感的场合，优先考虑Parallell Scavenge和Parallel Old组合
		//CMS收集器是一种以最短回收停顿为目标的收集器，采用的是标记清除算法，重视服务的响应速度，其包括初始标记、并发标记、重新标记、并发清除，初始标记和重新标记仍然需要暂停用户线程，初始标记仅仅只是标记一下GC Roots能直接关联到到的对象，速度很快
			//并发标记阶段就是进行GC RootsTracing的过程，重新标记是为了修正并发标记期用户线程继续运作而导致标记产生变动的那一部分重新标记记录，这个阶段会比初始标记时间稍长，但远比并发标记的时间短。CMS默认启动的回收线程数
			//是（CPU数量+3）／4，当cpu是4个以上时，并发回收垃圾的线程数不低于25%，当CPU不足四个时，影响更大
		//G1是新生代和老年代共用的垃圾收集器，采用标记整理和复制算法，不适合吞吐量高的场景
}
