package virtualmachine;
/**
 * 运行时数据区
 * @author gaobo
 *
 */
public class RuntimeDataArea {

	//1.程序计数器：当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令。如果线程执行一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令
		//如果是一个native方法则指向空，该区域是唯一一个没有任何OutOfMemoryError的区域。
	//2.java虚拟机栈：线程私有，生命周期与线程相同，描述的是java方法的内存模型，每个方法执行时会创建一个栈帧用于存储局部变量、操作数栈、动态链接、方法出口等信息。每一个方法从调用直到完成的过程，就对应着一个栈帧在虚拟机出栈到入栈的过程。
		//该区域两种异常情况：
			//1.当线程请求的栈深度大于虚拟机允许的深度会抛出StackOverFlowError
			//2.如果扩展时无法	申请到足够的内存，会抛出OutOfMemoryError的异常。
	//3.本地方法栈：与虚拟机栈相似，区别时虚拟机栈执行java方法（字节码）服务，本地方法栈执行native方法，也会抛出StackOverFlowError和OutOfMemoryError
	//4.java堆：存放对象实例，线程共享，从内存回收角度来看，java堆分为新生代和老年代，再细致一点分为Eden区、From Survivor空间、To Survivor空间
	//5.方法区：线程共享，用于存储被虚拟机加载的类的信息、常量、静态变量、即使编译器编译后的代码，方法区无法满足内存分配的需求时会抛出OutOfMemoryError
			//运行时常量池时方法区的一部分，class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后在运行时常量池中存放
	
}
